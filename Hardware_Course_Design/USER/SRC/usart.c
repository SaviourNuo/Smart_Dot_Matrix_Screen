#include "sys.h"
#include "usart.h"	  
#include "oled.h"
////////////////////////////////////////////////////////////////////////////////// 	 
//如果使用ucos,则包括下面的头文件即可.
#if SYSTEM_SUPPORT_UCOS
#include "includes.h"					//ucos 使用	  
#endif


//////////////////////////////////////////////////////////////////
//加入以下代码,支持printf函数,而不需要选择use MicroLIB	  
#if 1
#pragma import(__use_no_semihosting)             
//标准库需要的支持函数                 
struct __FILE 
{ 
	int handle; 

}; 

//FILE __stdout;       
//定义_sys_exit()以避免使用半主机模式    
//void _sys_exit(int x) 
//{ 
//	x = x; 
//} 
//重定义fputc函数 
//int fputc(int ch, FILE *f)
//{      
//	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
//    USART1->DR = (u8) ch;      
//	return ch;
//}
#endif 

/*使用microLib的方法*/
 /* 
int fputc(int ch, FILE *f)
{
	USART_SendData(USART1, (uint8_t) ch);

	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET) {}	
   
    return ch;
}
int GetKey (void)  { 

    while (!(USART1->SR & USART_FLAG_RXNE));

    return ((int)(USART1->DR & 0x1FF));
}
*/
 
#if EN_USART1_RX   //如果使能了接收
//串口1中断服务程序
//注意,读取USARTx->SR能避免莫名其妙的错误   	
u8 USART_RX_BUF[USART_REC_LEN];     //接收缓冲,最大USART_REC_LEN个字节.
//接收状态
//bit15，	接收完成标志
//bit14，	接收到0x0d
//bit13~0，	接收到的有效字节数目
u16 USART_RX_STA=0;       //接收状态标记	  
  
void uart_init(u32 bound){
    //GPIO端口设置
    GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	 
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO, ENABLE);	//使能USART1，GPIOA时钟以及复用功能时钟
     //USART1_TX   PA.9  蓝牙的RXD连接板子的TXD
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
    GPIO_Init(GPIOA, &GPIO_InitStructure);
   
    //USART1_RX	  PA.10  蓝牙的TXD连接板子的RXD
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
    GPIO_Init(GPIOA, &GPIO_InitStructure);  

   //Usart1 NVIC 配置

    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//子优先级3
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
  
   //USART 初始化设置

	USART_InitStructure.USART_BaudRate = bound;//一般设置为9600;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式

    USART_Init(USART1, &USART_InitStructure); //初始化串口
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启中断
    USART_Cmd(USART1, ENABLE);                    //使能串口 

}
//USART_RX_STA是接收状态标志，bit0-13用于计数，表示收到了几个数据，bit14为0x0d标志位，bit15为接收完成标志位
//(接收到的数据必须是0x0d 0x0a结尾，这个是固定的回车符号)
void USART1_IRQHandler(void)                	//串口1中断服务程序
{
	u8 Res;
#ifdef OS_TICKS_PER_SEC	 	//如果时钟节拍数定义了,说明要使用ucosII了.
	OSIntEnter();    
#endif
	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断，判断串口是否接收到数据
	{
	
		Res =USART_ReceiveData(USART1);//(USART1->DR);	//Res用于读取接收到的最新数据
		if((USART_RX_STA&0x8000)==0)//接收状态标志的最高位也即bit15为1时表示接收数据完毕，否则接收未完成
		{//这里取最高位判断为0时说明接收还未完成
			if(USART_RX_STA&0x4000)//bit14为0x0d的接收标志位，为1时表示接收到了0x0d，此时与0x4000相与即取出bit14进行判断，进入准备接收0x0a状态
			{
				if(Res!=0x0a)USART_RX_STA=0;//若在接收到0x0d后的下一个字节不是0x0a，则接收错误,将USART_RX_STA置零重新开始
				else
				{
					USART_RX_STA|=0x8000;	//若0x0d和0x0a被连续接收，则接收完成，将最高标志位置1，其余位不变
                   
					return;
				}
			}
			else //若接收未完成且未接收到0X0d时
			{	
				if(Res==0x0d)//此时若最新收到的数据为0x0d，则进行接收完成的准备，将bit14置为1，其余位不变
					USART_RX_STA|=0x4000;
				else//之前没接收到0x0d，current的最新数据也不是，那就继续接收，说明没有“回车标志”
				{
					//USART_RX_BUF[USART_RX_STA&0X3FFF]=Res;
					LCD_WRChinese(USART_RX_STA&0XFF, Res);
					USART_RX_STA++;//串口中断接收到一个字节后就每次自增1
					if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;//若超出可接收的最大数量，则重新开始接收 
				}		 
			}
		}   		 
    } 
#ifdef OS_TICKS_PER_SEC	 	//如果时钟节拍数定义了,说明要使用ucosII了.
	OSIntExit();  											 
#endif
} 
#endif	
/*这里我有一个疑问，如果蓝牙的主机发送的就是0x0d或者0x0a，而这是有效数据应该如何处理？（经查找资料可知在ascii码中0x0d和0x0a前者表示回车\r，后者表示换行\n，
注意回车只是把光标移动到本行的首位置，换行只是将光标移动到下一行而列不变，平常习惯的“回车键”相当于二者的组合）在这个程序中，目前由于字模中0x0d和0x0a都代表了
具体的字，因此目前若接收到单个的0x0d或者希望连续显示0x0d,0x0a的两个汉字时会出错，目前我想到的方案是干脆就把0x0d和0x0a编一个不会用到的字符就行了*/

