#include "main.h"

int main(void)
{
	
	u8 len; //定义输入字符串的长度，确定屏幕显示的字数
    
    SystemConfiguration();  //系统初始化
    
    Lcd_Init();  //进行LCD初始化配置	
	LCD_Clear(BLACK,320,240); //控制背景颜色，第一个参数为背景颜色，后两个参数为初始化的尺寸
    OLED_BLK_Set(); //片初始化
    
	extern u16 BACK_COLOR, POINT_COLOR;//背景色，画笔色
	BACK_COLOR=BLACK; 
	POINT_COLOR=RED;
    
    uart_init(9600); //串口初始化
    Delay_ms(100);

    
	while(1)
	{
		if(USART_RX_STA&0x8000)  //当USART_RX_STA的最高位即bit15为1时，表示接收完成，进入显示逻辑，否则一直空循环
		{
			len=(u8)(USART_RX_STA&0XFF);  
            /*USART_RX_STA的低bit0-bit13位为计数位，判断一共接受了多少个数据，当&0xFF时
            表示将bit0-bit7的数字提取出来，也即若传入数据个数<=255可以不出差错传入，len为接收到数据的个数*/
            
			USART_RX_STA=0;  //将接收标志初始化，准备进行下一次中断接收
			LCD_ScrollDisplay(len);  //将接收到汉字的个数作为参数传入滚动方式选择函数
            
		}
	}
}


//这个方案显示不符合人类的阅读习惯，因此不放入正式程序
///*5.多排显示从上到下移动，需要注意的是，由于多排显示滚动时汉字不能再以完整的方式绘制
//因此无法只调用showhanzi，需要精确到像素点，因此需调用低层函数LCD_WR_DATA重写逻辑，此外，此函数
//只适用于一次显示的汉字所占据的屏幕像素高度小于240，也即不大于70个字，因为滚动到下方的汉字的下半部分会立即在屏幕的上半部分显示
//若大于70个字，则会导致上下覆盖*/
//        for(int y_start = 0;y_start<240;y_start+=4)
//        {//竖直方向滚动循环遍历，竖直方向汉字每次整体移动4个像素点  
//            for(int idx = 0;idx<STRING_LENGTH;idx++)
//            {// 对汉字数组内的所有字符下标做遍历              
//                        
//                uint8_t x_off = idx%DISPLAY_MAX_LENGTH; //指示当前行目前位置需要显示的汉字，取余操作定位行内绝对位置
//                uint8_t y_off = idx/DISPLAY_MAX_LENGTH; //指示目前位置需要显示的汉字在显示汉字区域内部的第几行，除法操作定位以行为单位的行绝对位置
//                uint16_t x_pos = (x_off*32)%320;  //指示目前位置需显示的汉字开始绘制的像素点的列位置，也即一个汉字最左侧
//                uint16_t y_pos = (y_start+y_off*32)%240;  //指示目前位置显示的汉字开始绘制的像素点行位置，也即一个汉字最上侧
//                uint8_t *temp=hanzi_3232+idx*(32*32/8); //当前指针每次偏移一个字所需的字节数，也即32*32/8=72个字节，指向8个bit的起始bit  
//                Address_set(x_pos,y_pos,MIN(x_pos+31,320),MIN(y_pos+31,240));
//                /*这里调用Address_set是为了开辟写入区域，起始坐标为当前写入像素的左上角xy坐标
//                终止坐标在“正常一个汉字显示边界”和“整个屏幕显示边界”中取最小值
//                用于区别正常屏内显示汉字和边界无法显示完整汉字的特殊情况
//                列坐标在这里其实没有影响，因为本滚动方式没有进行横向移动，且屏宽320可被字宽32整除
//                行坐标上最下方的汉字ypos+31会出现大于240的情况，因此取最小值为240，不再显示不完整的下半部分        
//                */
//                
//                for(uint8_t i=0;i<32*32/8 ;i++)  //一个汉字72个字节，以字节为单位循环
//                {//正常写汉字流程，与底层基本相同，但多了break判断
//                    if(y_pos+i/(32/8)>=240) break;  
//                    /*表示若当前汉字的初始行坐标y_pos+应当绘制的当前字节所在的行数>=240时，不再依照正常逻辑画点，跳出循环
//                    即最下方汉字的下半部分不再画出，不应用于此画点逻辑，而应在后面的if判断中画出
//                    这里32/8表示一行32个像素用4个字节表示，即4个字节表示某汉字一行的画点规律
//                    i/(32/8)逻辑类似上面的idx/DISPLAY_MAX_LENGTH，即计算当前应该绘制的字节在构成一个完整汉字的，
//                    以字节为单位的矩阵中处于第几行，除法操作用于定位行数*/
//
//                    for(uint8_t j=0;j<8;j++)
//                    {
//                        if((*temp&(1<<j))!=0)
//                            LCD_WR_DATA(RED);
//                        else
//                            LCD_WR_DATA(BLACK); 
//                    }
//                    temp++;
//                }//其余情况时，内部正常在单个字节内循环画点
//                
//                if(y_pos+31>=240) //若汉字移动到最下方无法完整显示时
//                { 
//                    temp=hanzi_3232+idx*(32*32/8);  //对应汉字的第一个绘制点
//                    Address_set(x_pos,0,MIN(x_pos+31,320),y_pos+31-240);  
//                    /*无法完整显示，则将起始行坐标重定位到最上方，终止列坐标的MIN没必要
//                    终止的行坐标为无法显示完整的汉字的下半部分区域，用于将最下方无法显示完整的汉字下半部分
//                    映射到屏幕最上方显示，达到循环的目的*/
//                    for(uint8_t i=0;i<32*32/8 ;i++,temp++)  
//                    //temp++放在括号内是由于若仍放在循环最后，则continue跳过本次循环时无法++，程序出错
//                    {
//                        if(y_pos+(i/(32/8))<240)  //同上，不完整汉字的上半部分不再画出，跳过
//                            continue;
//                        else 
//                        {
//                            for(uint8_t j=0;j<8;j++)
//                                if((*temp&(1<<j))!=0)   LCD_WR_DATA(RED);
//                                else   LCD_WR_DATA(BLACK); 
//                        }//下半部分在屏幕最上方显示
//                    }
//                }

//            }
//            LCD_Rect_Clear(BLACK,0,y_start,320,MIN(y_start+4,240));
//            /*由于之前的LCD_Clear()函数并不完善，只可以设定清屏的终止点，起始点固定(0,0),因此写LCD_Rect_Clear()函数
//            输入参数为清屏颜色和起始/终止坐标，从第0列，当前显示行开始，到最后一列，结束行为正常的隔4个像素的下一显示行或第240行*/
//        }

